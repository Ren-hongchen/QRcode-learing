# 2.编码数据

前面我们已经介绍了二维码对输入文本的四种编码方式(实际上是三种)，现在我们介绍一下具体的编码流程

## 选择纠错级别

在编码数据之前，我们需要选择我们二维码的纠错级别，在生活中，我们会发现有些二维码的中心有图案，但却不影响我们扫码识别，这说明二维码具有纠错能力，即使一部分信息发生改变，也能解码出正确信息。二维码规定了4种纠错级别，级别越高，纠错能力越强。

| Error Correction Level | **Error Correction Capability** |
| :--------------------: | :-----------------------------: |
|           L            |       Recovers 7% of data       |
|           M            |      Recovers 15% of data       |
|           Q            |      Recovers 25% of data       |
|           H            |      Recovers 30% of data       |

虽然纠错级别越高，纠错能力越强，但是这也意味着要生成更长的纠错码，在同样version的情况下，纠错码越长，能容纳的数据也就越少。即在同一版本情况下，数据容量随纠错级别提高而降低。

## 选择最小版本

选择完纠错级别，我们还要为二维码选择一个合适的version(大小)。

二维码具有40个version，最小为1，大小是21\*21，version2大小为25\*25，每一版本都比前一版本大4，一直到version40，大小为177*177

一个version的最大容量由纠错级别和编码方式决定，我们需要根据选择的编码模式和纠错级别来确定合适的version。

注：所有的容量信息可以在[character-capacities](https://www.thonky.com/qr-code-tutorial/character-capacities)找到

比如我们编码"HELLO WORLD"，长度为11，因为字符串只由大写字母和空格组成，所以我们选择Alphanumeric编码模式，纠错级别我们选择Q，根据上面的表我们得到使用Q级别和Alphanumeric编码时，version 1可以最多容纳长度为16的字符串，所以version 1就是最小的符合条件的二维码。

## 添加模式指示器(Mode Indicator)

现在正式进入编码数据的过程，二维码规定了我们必须在**数据开头**使用4-bit的模式指示器来指示我们使用了哪种编码模式

|  Mode Name   | Mode Indicator |
| :----------: | :------------: |
|   Numeric    |      0001      |
| Alphanumeric |      0010      |
|     Byte     |      0100      |
|    Kanji     |      1000      |

## 添加字符计数指示器(Character Count Indicator)

确定了模式指示器之后，我们还需根据输入文本的长度来确定字符计数指示器。流程如下：

**计算出输入文本的长度，并转换为二进制，并在其左侧补充0使其达到正确的长度A。**

而正确长度A由编码模式和选择的version共同决定，如下：

| version | Numeric | Alphanumeric |  Byte   |  Kanji  |
| :-----: | :-----: | :----------: | :-----: | :-----: |
|   1-9   | 10 bits |    9 bits    | 8 bits  | 8 bits  |
|  10-26  | 12 bits |   11 bits    | 16 bits | 10 bits |
|  27-40  | 14 bits |   13 bits    | 16 bits | 12 bits |

比如输入”HELLO WORLD“ 文本长度为11 转换为二进制为，1011，如果选择version 1 和Alphanumeric编码模式，根据上表，字符计数指示器长度应为9 bits，所以我们在1011左侧补充0直到长度达到9位，得到 000001011 。

**现在我们得到了字符计数指示器，根据标准，字符计数指示器必须在模式指示器之后，所以上面例子的最终数据应该为**

**001000001011**

## 编码数据

现在我们已经做好了准备工作，接下来就是编码数据

对于不同的输入文本类型，标准规定了不同的编码方法。

### **Numeric**

对于Numeric编码模式，我们假设输入为3452311，version 为 1

1. 我们把输入字符串三位一组分开，如果长度不是3的倍数，那么最后一组，可以是一位或两位
   对于我们的例子就是： 345 231 1

2. 我们把每一组都转换为10位的二进制数据，如果某一组以零开头，我们把它看做两位数转换为7位长，如果以两个零开头，那么看作是一位数，转换为4位长，同理如果最后一组有两个数字那就转换为7位，一个数转换为4位

345 -> 01 0101 1001

231 -> 00 1110 0111

​	1 -> 00 01

把得到的二进制数字拼接起来就得到了编码数据

### **Alphanumeric**

假设输入为 ”HELLO WORLD“ ，version为 1

1. 把输入文本以两个字符一组进行分组
   即 ”HE“ ”LL“ ”O “ ”WO“ ”RL“ ”D“ **注意第三组是O和空格一组**

2.  在上一节我们说到在[alphanumeric-table](https://www.thonky.com/qr-code-tutorial/alphanumeric-table)中，不仅包含所有的Alphanumeric字符，还有每个字符对应的数字，现在我们根据这个表获取每一组的字符对应的数字
   然后，**用第一个字符对应的数字乘以45，再加上第二个字符对应的数字。**

   比如查表得到 H为17，E为14，所以第一组对应数字为 (45 * 17) + 14 = 779

   现在，我们需要将计算得到的数字，转换为11位长的二进制数据，如果长度不够，我们依旧需要在左侧补0直到长度足够

   779 -> 011 0000 1011

​	3. 对于最后一组只有一个字符的情况，直接查表得到对应数字后，转换为6位长二进制即可。

### Byte

标准规定，Byte编码要使用ISO 8859-1编码，所以这里我们就按这个来

假设输入为”Hello, world"，version为 1，因为文本里包括小写字母，和一个逗号，所以只能使用Byte编码

1. 首先我们需要将文本转换为ISO 8859-1编码

2. 我们知道ISO 8859-1相当于ASCII码的超集，所以在ISO 8859-1里每个字符也是对应一个数字的。接下来我们只需将每个字符对应的数字转为8位长的二进制数据即可，老规矩，如果长度不够，在左侧补0

   H → 0x48 → 01001000
   
   e → 0x65 → 01100101
   
   l → 0x6c → 01101100
   
   l → 0x6c → 01101100
   
   o → 0x6f → 01101111
   
   , → 0x2c → 00101100
   
    → 0x20 → 00100000
   
   w → 0x77 → 01110111
   
   o → 0x6f → 01101111
   
   r → 0x72 → 01110010
   
   l → 0x6c → 01101100
   
   d → 0x64 → 01100100

## 数据分组和补充数据

经过上面的步骤我们已经得到了由模式指示器，字符计数指示器和编码之后的数据组成的一个字符串，以“HELLO WORLD"为例

0010 + 000001011 + 01100001011 01111000110 10001011100 10110111000 10011010100 001101

但还没有结束，二维码要求数据必须填满版本指定容量，所以还可能需要以下步骤

### 确定最大容量

一个二维码可以最多容纳的数据位可以在[error-correction-table](https://www.thonky.com/qr-code-tutorial/error-correction-table)找到，这个表中还有一些其他数据之后我们会用到。但现在我们只需关注**Total Number of Data Codewords for this Version and EC Level**这一列，根据选择的版本和纠错级别，我们就能找到具体的数字，比如version1-Q 得到最大容量为13，我们将其乘以8，得到104，所以我们得到的数据必须填充到104位，所以我们需要进行以下步骤：

1. **添加终止符**

如果我们在前面得到的数据和最大数据长度之间相距大于4位，那么在我们的数据末尾(右侧)添加”0000“来标识我们的数据到这里结束。

如果不足4位，则直接添加0使其达到最大长度。

对于我们的例子，距离最大长度还有30位，所以我们在其末尾(右侧)添加4个0000:

0010 + 000001011 + 01100001011 01111000110 10001011100 10110111000 10011010100 001101 + 0000

2. **添加更多的0使其长度达到8的倍数**

经过上面的步骤，我们的字符串长度达到了78位，接下来我们需要要把数据8位一组进行分组，因为现在78不是8的倍数，所以我们需要在末尾在添加两个0，使其长度达到80，即：

0010 + 000001011 + 01100001011 01111000110 10001011100 10110111000 10011010100 001101 + 0000 + 00

3. **添加补充字符**

如果经过上面的步骤，数据还没有到达最大长度，我们需要在其末尾在添加补充字符。

补充字符由 **11101100和00010001**组成，我们需要在其末尾**交替**添加前面两个8位字符串，直到达到最大长度。如：

0010 + 000001011 + 01100001011 01111000110 10001011100 10110111000 10011010100 001101 + 0000 + 00 +

11101100 00010001 11101100

---

现在经过上面所有的步骤，我们就得到了一个对数据进行编码后的字符串，接下来我们需要对这些数据生成纠错码。

