# 生成纠错码

现在我们来到了生成二维码最复杂的步骤，里面涉及了很多数学知识，我将尽我最大努力解释清楚。

## 多项式除法

首先，我们需要了解下多项式长除法，相信很多读者已经知道这一数学方法了，但我这里还是介绍一下。比如：
$$
x+1\sqrt{3x^2 + x - 1}
$$
PS：我不知道怎么打出那个除法符号，所以这里就用根号代替了

在多项式除法中，我们总要求除式乘以某项后第一项与被除式第一项完全相等，比如这里我们需要
$$
(x + 1) * 3x = 3x^2 + 3x
$$
这个式子首项和被除式首项都是3x^2^ 

用被除式减去上述结果得到：
$$
(3x^2 + x - 1) - (3x^2 + 3x) = -2x -1
$$
我们发现，最高次项系数为0，省略掉了。接下来我们用得到的新式子作为被除式重复上述步骤：
$$
(x + 1) * (-2) = -2x - 2
$$

$$
(-2x - 1) - (-2x - 2) = 1
$$

我们发现结果只剩常数，除法这时已经不能进行下去，我们的结果是每次除法乘以的项之和，即3x -2，当然还有余数项 1

总结一下就是：

1. 在每次除法过程中，需要找到一个合适的项乘以除式使除式第一项的系数和指数都与被除式第一项完全相同。
2. 用被除式减去第一步乘法产生的结果，得到的式子作为第二次除法的被除式。
3. 重复上述过程，直到找不到一个整数项来继续除法。

我们后续使用的Reed-Solomon Error Correction算法和这个过程很像，但还有一个重要的地方，我们需要理解。

## 伽罗瓦域

二维码标准说需使用按位模 2 算术和按字节模 100011101 算术。即必须在伽罗瓦域256中进行运算，即GF(256).

GF(256)中的数都在0-255这个区间内，这意味着所有的数表示为二进制都在8位以内。

GF(256)的数学特性保证在域中的所有数学运算产生的结果也在GF(256)内，即所有运算只能产生最多8位的二进制数据。

每当产生一个大于255的数，我们必须使用模运算，产生一个新的数字使其处于GF(256)内。

此外，GF(256)中的数学运算也有所不同，在GF(256)中，正数与负数相等，即-n=n。

也就是说，减法与加法等价，且因为需要使用按位模2运算，所以在GF(256)中加减法与异或等价，即
$$
1 + 1 = 2 \oplus 2= 0
$$

$$
1 + 0 = 1 \oplus 2 =1
$$

等价于
$$
1 \oplus 1 = 0
$$

$$
1 \oplus 0 = 1
$$

GF(256)的另一个特性是，GF(256)中所有数都可以表示为$2^n$，其中$( 0 \le n \le 255)$,

2^1^ = 2,   2^2^ = 4,   2^3^ = 8,   2^4^ = 16,   2^5^ = 32,   2^6^ = 64,   2^7^ = 128,   2^8^ = 256

我们发现2^8^ = 256 已经超过了GF(256)的范围，而二维码标准规定我们需要让其与100011101(十进制285)进行异或运算。
$$
2^8 = 256 \oplus 285 = 29
$$
 这样就又回到了GF(256)中，对于2^9^ 如果我们先计算出512 再与285异或会得到797，更大了

而应该这么做，$2^9 = 2^8 * 2 = 29 * 2 = 58$

如此进行，每一个数都是前一个数的二倍，直到下一个数超过255，再与285异或运算。一直到n = 255

---

之后我们已经解释过了GF(256)里的加减法，现在我们介绍一下乘法。

根据log的运算性质，两个数p和q相乘可以表示为：
$$
a^\left(\log_{a}{p} + \log_{a}{q}\right)
$$
这里的a我们可以换成2，也就是等价于：
$$
2^\left(\log_{2}{p} + \log_{2}{q}\right)
$$
所以对于GF(256)中的两个数相乘，如32 * 64，即p = 32，q = 64，那么log~2~^32^ = 5, log~2~^64^ = 6,

所以32 * 64 = 2^(5+6)^ = 2^11^  = 232 **注意：这是在GF(256)中的运算，所以所有数都可以表示为2^n^ 的形式**

对于相乘结果指数超过255的，我们需要对其以255求模，如

2^170^ * 2^164^ = 2^(170+164)^ = 2^334^ = 2^(334%255)^  = 2^79^ 

 因此对于GF(256)中的乘法就是找到相乘的两个数在GF(256)中的指数表示再相乘即可。

这个信息可以在[log-antilog-table](https://www.thonky.com/qr-code-tutorial/log-antilog-table)找到，也可以自己实现算法生成。

## 消息多项式和生成多项式

前面我们提到Reed-Solomon Error Correction算法需要使用到多项式除法，所以我们需要有两个多项式，消息多项式(Message Polynomial)和生成多项式(Generator Polynomial)。

### 消息多项式

消息多项式其实我们在编码数据的过程中已经拿到了，编码数据的时候，我们要求数据必须是8的倍数，现在我们将数据8位一组进行分组。如“HELLO WORLD” version1-M(**注意这里和上一节纠错级别不一样**)

00100000 01011011 00001011 01111000 11010001 01110010 11011100 01001101 01000011 01000000 11101100 00010001 11101100 00010001 11101100 00010001

每组转化为十进制：

32, 91, 11, 120, 209, 114, 220, 77, 67, 64, 236, 17, 236, 17, 236, 17

这些数字就是消息多项式的系数，即
$$
32x^{15}+91x^{14}+11x^{13}+...+17x^{2}+236x+17
$$


## 生成多项式

生成多项式的定义也很简单，它由这样的一个式子决定：
$$
P(n) = (x-\alpha^{0})...(x-\alpha^{n-1})
$$
在二维码中α = 2，而n取决于你要生成多长的纠错码，不同版本，不同纠错级别需要不同长度的纠错码，我们可以在之前的表[error-correction-table](https://www.thonky.com/qr-code-tutorial/error-correction-table)中找到**EC Codewords Per Block**这一栏查看具体信息。

比如，我们要生成P(2):
$$
P(2) = (x-2^0)(x-2^1) = (2^0x-2^0)(2^0x-2^1)
$$
我们乘开得到，
$$
2^{0}x^{2}+(2^0+2^1)x+2^1
$$
由于我们是在GF(256)中运算，所以加法等同于异或运算，我们将数字从2^n^ 的形式转化为整数形式并异或，得到
$$
2^0x^2+(1\oplus2)x+2^1 = 2^0x^2+3x+2^1
$$
所以原式变为$x^2+3x+2$,表示为2^n^ 的形式为，$2^0x^2+2^{25}x+2^1$

现在我们就得到了P(2)的表达式，那么P(3)呢？
$$
P(3) = (x-2^0)(x-2^1)(x-2^2) = P(2)(x-2^2)
$$
乘开得到，
$$
2^0x^3+(2^{25}+2^2)x^2+(2^1+2^{27})x+2^3
$$

$$
2^0x^3+(2^{25}\oplus2^2)x^2+(2^1\oplus2^{27})x+2^3
$$

$$
2^0x^3+(3\oplus4)x^2+(2\oplus12)x+2^3
$$

$$
2^0x^3+7x^2+14x+2^3
$$

$$
2^0x^3+2^{198}x^2+2^{199}x+2^3
$$

现在我们得到了P(3)，至于P(4),P(5)...依照这个方法都可以计算出来。

**当我们展开多项式进行乘法运算时，指数部分超过255的要对255求模，如**$2^{257}x+2^{(257\mod255)}x+2^2x$

注：可以在[generator-polynomial-tool](https://www.thonky.com/qr-code-tutorial/generator-polynomial-tool)检验你计算的生成多项式正确性

## Reed-Solomon Error Correction算法

所有准备工作已经结束了，现在我们来看看怎么生成正确的纠错码。

我们以version 1-M的HELLO WORLD为例

消息多项式前面我们已经计算出来了：
$$
32x^{15}+91x^{14}+11x^{13}+...+17x^{2}+236x+17
$$
生成多项式部分，我们查[error-correction-table](https://www.thonky.com/qr-code-tutorial/error-correction-table)可知，version 1-M二维码需要长度为10的纠错码，即
$$
P(10) = x^{10} + 2^{251}x^9 + 2^{67}x^8 + 2^{46}x^7 + 2^{61}x^6 + 2^{118}x^5 + 2^{70}x^4 + 2^{64}x^3 + 2^{94}x^2 + 2^{32}x + 2^{45}
$$
现在我们进行多项式除法，

### Step 1

我们必须保证多项式首项的指数能完成整个除法过程，所以我们对消息多项式乘以2^n^ 其中n等于所需纠错码的长度，我们的例子中n=10

**注：实际上我们在编程时，我们可以只关注系数的运算， 而忽略这一步**

所以现在消息多项式变为：
$$
32x^{25}+91x^{24}+11x^{23}+...+17x^{12}+236x^{11}+17x^{10}
$$
现在我们需要让生成多项式的首项和消息多项式的首项指数一致，所以消息多项式变为：
$$
x^{25}+2^{251}x^{24}+2^{67}x^{23}+ 2^{46}x^{22} + 2^{61}x^{21} + 2^{118}x^{20} + 2^{70}x^{19} + 2^{64}x^{18} + 2^{94}x^{17} + 2^{32}x^{16} + 2^{45}x^{15}
$$
接下来我们要进行多少次除法？这个数应该等于消息多项式中的项数，这里是16，也就是说我们要进行16次迭代计算。

### Step 2

现在我们需要让生成多项式第一项的系数也等于消息多项式，即生成多项式需要乘以32

因为我们是在GF(256)中计算，所以32=2^5^ ,这样我们计算比较方便，现在我们得到：
$$
2^5x^{25}+2^{256}x^{24}+2^{72}x^{23}+ 2^{51}x^{22} + 2^{66}x^{21} + 2^{123}x^{20} + 2^{75}x^{19} + 2^{69}x^{18} + 2^{99}x^{17} + 2^{37}x^{16} + 2^{50}x^{15}
$$
因为第二项的指数超过了255，所以让它对255求模，$2^{(256 \mod 255)} = 2^1$，所以正确的表达式为：
$$
2^5x^{25}+2^{1}x^{24}+2^{72}x^{23}+ 2^{51}x^{22} + 2^{66}x^{21} + 2^{123}x^{20} + 2^{75}x^{19} + 2^{69}x^{18} + 2^{99}x^{17} + 2^{37}x^{16} + 2^{50}x^{15}
$$
转化为整数形式：
$$
32x^{25} + 2x^{24} + 101x^{23} + 10x^{22} + 97x^{21} + 197x^{20} + 15x^{19} + 47x^{18} + 134x^{17} + 74x^{16} + 5x^{15}
$$

### Step 3

现在我们消息多项式减去上一步新生成的多项式，因为在GF(256)中，减法等同于异或，所以如下：
$$
(32\oplus32)x^{25} + (91 \oplus 2)x^{24} + (11 \oplus 101)x^{23} + (120 \oplus 10)x^{22} + (209 \oplus 97)x^{21} \\+ (114 \oplus 197)x^{20} + (220 \oplus 15)x^{19} + (77 \oplus 47)x^{18} + (67 \oplus 134)x^{17} + \\(64 \oplus 74)x^{16} + (236 \oplus 5)x^{15} + (17 \oplus 0)x^{14} + (236 \oplus 0)x^{13} + (17 \oplus 0)x^{12} + (236 \oplus 0)x^{11} + (17 \oplus 0)x^{10}
$$
结果为：
$$
0x^{25} + 89x^{24} + 110x^{23} + 114x^{22} + 176x^{21} + 183x^{20} + 211x^{19} + 98x^{18} + 197x^{17} +\\ 10x^{16} + 233x^{15} + 17x^{14} + 236x^{13} + 17x^{12} + 236x^{11} + 17x^{10}
$$
我们去掉系数为0的前导项：
$$
89x^{24} + 110x^{23} + 114x^{22} + 176x^{21} + 183x^{20} + 211x^{19} + 98x^{18} + 197x^{17} +\\ 10x^{16} + 233x^{15} + 17x^{14} + 236x^{13} + 17x^{12} + 236x^{11} + 17x^{10}
$$

**注：这里有个问题需要注意，在某种情况下，异或之后我们的式子前n项系数都为0，这时候我们还是应该只去掉第一项系数为0的项，这是因为我们的除法计算一次只计算一项，如果你去掉了前面所有n个零项，那么我们将漏掉n-1次计算。正确的做法是，在下次运算时，如果多项式首项还为0，应该去掉第一个零项，而直接进入下一次运算，看似什么都没做，实际上消耗了一次迭代次数。**

### Step 4

然后使用上一步最终式的首项(89x^24^)乘以生成多项式，89 -> 2^210^ ,生成多项式每一项乘以2^210^ .......

接下来就是重复计算过程，在经过16次(消息多项式的长度)计算后，

得到的式子(去掉0首项)的系数，即为纠错码。另外，最后式子也应该为所求纠错码的长度。

对于本例来说，最后我们得到：
$$
196x^9 + 35x^8 + 39x^7 + 119x^6 + 235x^5 + 215x^4 + 231x^3 + 226x^2 + 93x^1 + 23
$$
取其系数为纠错码，即：
$$
196\space35\space39\space119\space235\space215\space231\space226\space93\space23
$$

## 总结

现在我们已经得到了编码好的数据和对应的纠错码，下一节我们来构建最终的数据。
