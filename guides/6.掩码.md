# 6.掩码

在填入数据后，我们还需要对齐进行掩码，来让扫描端更好的解码出数据。

掩码实际上就是对我们填好的二维码的特定位置，进行“颜色翻转”，也就是说，对符合条件的位置的数据，0变为1，1变为0，

黑块变白块，白块变黑块。

## 掩码模式

二维码标准定义了8种掩码模式，即8种条件，对符合条件的位置进行翻转：

| 掩码模式 |                             条件                             |
| :------: | :----------------------------------------------------------: |
|    0     |                  (row + column) mod 2 == 0                   |
|    1     |                       (row) mod 2 == 0                       |
|    2     |                     (column) mod 3 == 0                      |
|    3     |                  (row + column) mod 3 == 0                   |
|    4     |      ( floor(row / 2) + floor(column / 3) ) mod 2 == 0       |
|    5     |     ((row * column) mod 2) + ((row * column) mod 3) == 0     |
|    6     | ( ((row * column) mod 2) + ((row * column) mod 3) ) mod 2 == 0 |
|    7     | ( ((row + column) mod 2) + ((row * column) mod 3) ) mod 2 == 0 |

假设，二维码(2,5)位置上数据为1，对齐应用掩码模式1，（row）mod 2 == 0 成立，所以翻转，(2,5)的数据变为0

**注：我们只能对数据区域进行掩码，所有的功能模式，保留区域都不变**

**注：我们只能对数据区域进行掩码，所有的功能模式，保留区域都不变**

**注：我们只能对数据区域进行掩码，所有的功能模式，保留区域都不变**

## 选择掩码模式

一个二维码只能选择一个最合适的掩码模式，所以，在应用每一种掩码模式后，我们对其计算出一个惩罚分数，然后选择拥有最低分数的掩码模式为最佳模式。

### 一个奇怪的问题

**当我们计算惩罚分数时，我们需要对二维码所有位置进行计算，也就是说功能模式，保留区域等都是被计算在内的**，而且这时的保留区域应该是已经填充好的状态，所以在计算分数前，我们应该先填充保留区域。而填充的具体步骤在下一节。不过这里我们就假设已经填充好了。

### 惩罚分数计算规则

惩罚分数一共有4条计算规则：

#### 规则1

1. 我们检查二维码每一行，如果有连续5个块都是同一颜色，惩罚分数加3分，连续5块后，每增加一块，加1分。

2. 以同样的规则检查每一列，计算列的惩罚分数

3. 将行和列的惩罚分数加起来，即规则1下的惩罚分数。

   ![img](https://www.thonky.com/qr-code-tutorial/horizontal-total.png)

![img](https://www.thonky.com/qr-code-tutorial/vertical-total.png)

#### 规则2

对于规则2，我们在二维码中寻找大于等于2\*2的纯色块，二维码标准规定，对于m\*n的纯色块，惩罚分数为3\*(m-1)*(n-1)

但没有规定，当一个纯色块有多种分割方式，如何计算分数。

这里我们选择不去查找更大的纯色块，而直接每行每列查找有多少个2\*2纯色块，对于一个3\*3的纯色块，以这种方式将由4个2\*2组成，

惩罚分数为3*4 = 12，符合公式。

![img](https://www.thonky.com/qr-code-tutorial/penalty-2.png)

#### 规则3

第三条规则看起来有点奇怪，我们需要在二维码中寻找以下两种特定形状：

![img](https://www.thonky.com/qr-code-tutorial/penalty-3-pattern1.png)

![img](https://www.thonky.com/qr-code-tutorial/penalty-3-pattern2.png)

每找到一个我们直接惩罚分数加40

![img](https://www.thonky.com/qr-code-tutorial/penalty-3.png)

如上就是80

#### 规则4

第四个规则，是一个纯计算规则：

1. 计算二维码数据位总数
2. 计算在二维码中一共有多少黑色块(暗模块)
3. 计算暗模块占总数的比例（darkmodules/totalmodules）*100
4. 找到第三步比例的前一个5的倍数和后一个5的倍数。比如上一步结果为41，那前一个倍数为40，后一个倍数为45
5. 将两个倍数减去50，并取绝对值，即|40 - 50| = 10，|45 - 50| = 5
6. 每个数分别除以5，10 / 5 = 2， 5 / 5 = 1
7. 取两个数最小值乘以10，即为最终惩罚分数。 1 * 10 = 10

![img](https://www.thonky.com/qr-code-tutorial/rule-4-illust2.png)

以此图，为例

第一步计算比例为 213 / 441 = 48 （取整了）

所以前一个5的倍数为 45，后一个5的倍数为 50

每一个数都减去50，并取绝对值，|45 - 50|  = 5，|50 - 50| = 0

每个数在除以5，5 /5 = 1， 0 / 5 = 0

取最小值乘以10 ，0 * 10 = 0 ，所以最终分数为0

## 总结

对于选定的掩码模式，**将上述4种规则的惩罚分数相加，即为最终分数。**

然后，我们选取拥有最低惩罚分数的掩码模式。

并且，**使用了掩码模式后得到的二维码图案即为我们最终输出的二维码图案。**

但正如我们前面提到的，在进行计算惩罚分数前，我们需要先进行填充保留区域步骤，所以我们进行最后步骤。